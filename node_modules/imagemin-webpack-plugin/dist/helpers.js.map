{"version":3,"sources":["../src/helpers.js"],"names":["imageData","imageminOptions","imageBuffer","Buffer","isBuffer","from","originalSize","length","buffer","optimizedImageBuffer","optimizeImage","cacheFolder","content","elseFunc","cacheFilePath","resolve","hashContent","exists","readFile","fileBuffer","writeFile","getFromCacheIfPossible","directory","reject","access","constants","R_OK","W_OK","err","filename","dirname","mkdirpAsync","writeFileAsync","buildTestFunction","invokeIfFunction","templatedFilePath","rawTestValue","minFileSize","maxFileSize","testFunctions","compileRegex","assetSource","func","createHash","update","digest","tests","Array","isArray","map","test","RegExp","regex","Error","fileName","filePath","originalFilePath","replace","split","basename","extname"],"mappings":"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","file":"helpers.js","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport crypto from 'crypto'\nimport { makeRe } from 'minimatch'\nimport imagemin from 'imagemin'\nimport mkdirp from 'mkdirp'\nimport promisify from 'util.promisify'\n\nexport const readFile = promisify(fs.readFile)\nconst writeFileAsync = promisify(fs.writeFile)\nconst mkdirpAsync = promisify(mkdirp)\n\n/**\n * Optimizes a single image, returning the orignal if the \"optimized\" version is larger\n * @param  {Object}  imageData\n * @param  {Object}  imageminOptions\n * @return {Promise(asset)}\n */\nexport async function optimizeImage (imageData, imageminOptions) {\n  // Ensure that the contents i have are in the form of a buffer\n  const imageBuffer = (Buffer.isBuffer(imageData) ? imageData : Buffer.from(imageData, 'utf8'))\n  // And get the original size for comparison later to make sure it actually got smaller\n  const originalSize = imageBuffer.length\n\n  // Await for imagemin to do the compression\n  const optimizedImageBuffer = await imagemin.buffer(imageBuffer, imageminOptions)\n\n  // If the optimization actually produced a smaller file, then return the optimized version\n  if (optimizedImageBuffer.length < originalSize) {\n    return optimizedImageBuffer\n  } else {\n    // otherwize return the orignal\n    return imageBuffer\n  }\n}\n\n/**\n * Tests a filename to see if it matches any of the given test functions\n * This function is curried, pass in the first 3 params first, then the next 2\n * for each test needed\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @param  {Number} minFileSize\n * @param  {Number} maxFileSize\n * @return {Boolean}\n */\nexport function buildTestFunction (rawTestValue, minFileSize, maxFileSize) {\n  const testFunctions = compileRegex(rawTestValue)\n  /**\n   * @param  {String}      filename\n   * @param  {assetSource} assetSource\n   * @return {Boolean}\n   */\n  return (filename, assetSource) => {\n    for (let func of testFunctions) {\n      if (func(filename) === true) {\n        return assetSource.length > minFileSize && assetSource.length <= maxFileSize\n      }\n    }\n    return false\n  }\n}\n\n/**\n * hashes file contents to make sure I can uniquely store a file even with absolute paths\n * @param  {string} content  File contents\n * @return {string}          A hash of the full file contents\n */\nexport function hashContent (content) {\n  return crypto.createHash('sha1').update(content).digest('hex')\n}\n\n/**\n * Invokes the passed in argument if it's a function\n * @param  {Function|Any}  func\n * @return {Any}\n */\nexport function invokeIfFunction (func) {\n  if (typeof func === 'function') {\n    return func()\n  } else {\n    return func\n  }\n}\n\n/**\n * Gets the buffer of the file from cache. If it doesn't exist or the cache is\n * not enabled, it will invoke elseFunc and use it's result as the result of the\n * function, saving the result in the cache\n * @param  {String} cacheFolder\n * @param  {String} content\n * @param  {Function} elseFunc\n * @return {Buffer}\n */\nexport async function getFromCacheIfPossible (cacheFolder, content, elseFunc) {\n  let cacheFilePath\n  if (cacheFolder !== null) {\n    cacheFilePath = path.resolve(cacheFolder, hashContent(content))\n    if (await exists(cacheFilePath)) {\n      return readFile(cacheFilePath)\n    }\n  }\n\n  const fileBuffer = await elseFunc()\n  if (cacheFolder !== null) {\n    await writeFile(cacheFilePath, fileBuffer)\n  }\n  return fileBuffer\n}\n\n/**\n * checks if a file/directory is accessable\n * @param {any} directory\n * @returns\n */\nexport async function exists (directory) {\n  return new Promise((resolve, reject) => {\n    fs.access(directory, fs.constants.R_OK | fs.constants.W_OK, (err) => {\n      if (err) {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}\n\n/**\n * async wrapper for writeFile that will create the directory if it does not already exist\n * @param {String} filename\n * @param {Buffer} buffer\n * @returns\n */\nexport async function writeFile (filename, buffer) {\n  const directory = path.dirname(filename)\n  // if the directory doesn't exist, create it\n  if (!(await exists(directory))) {\n    await mkdirpAsync(directory)\n  }\n\n  return writeFileAsync(filename, buffer)\n}\n\n/**\n * Compiles a regex, glob, function, or an array of any of them to an array of functions\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @return {Function[]}\n */\nfunction compileRegex (rawTestValue) {\n  const tests = Array.isArray(rawTestValue) ? rawTestValue : [rawTestValue]\n\n  return tests.map((test) => {\n    if (typeof test === 'function') {\n      // if it's a function, just return this\n      return test\n    } else if (test instanceof RegExp) {\n      // If it's a regex return it wrapped in a function\n      return (filename) => test.test(filename)\n    } else if (typeof test === 'string') {\n      // If it's a string, let minimatch convert it to a regex then wrap that in a function\n      const regex = makeRe(test)\n      return (filename) => regex.test(filename)\n    } else {\n      throw new Error('test parameter must be a regex, glob string, function, or an array of any of them')\n    }\n  })\n}\n\n/**\n * Replaces file name templates for a given path. Inspired by webpack's output.filename config.\n * @param {String|Function} fileName\n * @param {String} filePath\n * @returns {String}\n */\nexport function templatedFilePath (fileName, filePath) {\n  if (typeof fileName === 'function') {\n    return fileName(filePath)\n  }\n\n  if (typeof fileName === 'string') {\n    const originalFilePath = filePath\n\n    return fileName\n      .replace('[path]', originalFilePath.split(path.basename(originalFilePath))[0])\n      .replace('[name]', path.basename(originalFilePath, path.extname(originalFilePath)))\n      .replace('[ext]', path.extname(originalFilePath).split('.')[1])\n  }\n\n  throw new Error('fileName parameter must be a string or a function')\n}\n"]}